```cpp
int* a[10]; // массив из 10 указателей на int (сначала читается то, что справа, а потом то, что слева)

int (*b)[10]; // указатель на массив из 10 int
```
Мы берем то, что в скобках, читаем сначала то, что справа, потом то, что слева, потом выходим из скобок, опять читаем то, что справа, потом то, что слева и так далее

```cpp
void (*pf)(int); // pointer to function which takes int, return void
```
Указатель на функцию, которая принимает int и возвращает void

Но мы сталкиваемся с проблемами, когда хотим объявить указатель на функцию, которая сама возвращает указатель на функцию, или указатель на функцию, которая возвращает массив, или массив указателей на функцию

```cpp
void (*pfa[10])(int);
```
Массив из 10 указателей на функцию, принимающую int и возвращающую void

```cpp
 void (*(*pff[10])(int))(int)
```
Массив из 10 указателей на функцию, которая принимает int, а возвращает указатель на функцию, которая принимает int, а возвращает void

Это все объявления из языка C. Так называемый `cdecl`

*Если вижу справа круглые скобочки, значит это была функция*

[Сайт про C type declarations](http://unixwiz.net/techtips/reading-cdecl.html)

Имя переменной пишется в самых внутренних скобочках. Но мы можем не писать имя переменной, если мы хотим скастовать или передать в `sizeof`

```cpp
int (*(*)())()
```
Указатель на функцию, которая ничего не принимает, а возвращает указатель на функцию, которая ничего не принимает, а возвращает int

### References (ссылки)
В C у нас были указатели - адрес в памяти, по которому лежит переменная. Если мы хотим, чтобы функция меняла исходную переменную, то нам надо передавать туда не саму переменную, а указатель на нее

Создатель подумал, что это неудобно и решил ввести новую концепцию - ***Reference (ссылка)***

У меня есть какая-то переменная `int x = 5`. Я могу захотеть создать для этой переменной другое название, чтобы переменная вроде как была другая, но на самом деле объект был тот же самый, ячейка в памяти ей соответствовала та же самая. Ну и чтобы я мог вызвать функцию от этой штуки и если я тут ее поменяю, то поменялась бы именно та самая, исходная переменная

*Для этого была придумана концепция ссылок*

Я могу написать 
```cpp
int x = 5;
int& y = x;
```
`y` - ссылка на x

Соответственно можем и в функции так же сделать - можем создать функцию, которая принимает не int, а ссылку на int. Тем самым когда мы туда отдадим x, получится что мы изменили бы его самого.
```cpp
void f(int& y) {
	++y;
}

int x = 5;
f(x); // изменим тот самый x, хоть он и называется по другому
```
`y` в функции это тот же самый int, что был изначально. Это не новый int, а ссылка на него, то есть это имя соответствует тому же самому int, который был изначально

Можно проследить некую аналогию с Python/Java 

![](../images/Pasted%20image%2020240925114838.png)

В плюсах всегда, когда мы говорим что-то там равно чему-то мы всегда этим действием создаем новый объект
```cpp
std::string s = "abc";
std::string s2 = s;
```
У меня теперь существует две строки. Так работает с любым типом. Честно копируется, `s` и `s2` - это два разных объекта

Чтобы добиться поведения как в Python, чтобы сказать не создай мне новый объект, а создай мне новое имя старого объекта, я могу написать 
```cpp
std::string s = "abc";
std::string& s2 = s;
```
Теперь `s2` это новое имя старого объекта, а сам объект реально один

Почему мы не можем позволить себе такую роскошь как в Python - присваивание автоматически по ссылке? Как нам тогда понять когда у этого объекта закончилось время жизни, когда нам его удалять из памяти, как в рантайме понять - этому объекту еще соответствует какое-то имя или нет? Для этого нужен сборщик мусора, а у нас его нет

Поэтому в плюсах, если мы хотим создать новое имя старому объекту, то пишем `type&`, а если мы так не напишем, то создадим новый честный объект

Как в таком случае уничтожать объект? Когда у нас выходит из области видимости вот такой тип `type&`, то с объектом ничего не происходит, а когда выходит из области видимости вот такой настоящий тип `type`, то объект уничтожается. 

***Теперь это решаемо в Compile-Time - когда должен уничтожаться объект***

```cpp
int x = 5;
int& y = x;

int z = 7;
y = z; // то же самое что и x = z;
```
`y` и `x` - это два названия одного и того же, они неотличимы с точки зрения нас как программиста

```cpp
int& t = y; // сказал, что t ссылка на x

sizeof(y) // 4, потому что sizeof(int) == 4, y это все равно что x

&y == &x // адреса у них одинаковые
&y // тип этого выражения int*
```

***Нельзя сделать ссылку на ссылку***

Когда мы в функцию принимаем что-то по ссылке, это означает, что мы в области видимости функции создали себе переменную, обозначающую ту самую переменную, которую передали, и обращение к ней внутри функции, это обращение переменной вне функции

На низком уровне это скорее всего реализовано через указатели

```cpp
void f(int& y) {
	++y;
}

void f(int x) {
	++x;
}

int x = 5;
int& y = x;

f(x);
f(y);
```
Это CE со словами ambigious call - не понятно, от чего вызваться. При чем CE будет не в момент, когда я эти функции объявил, а в момент, когда я вызываюсь

Вызвать f(x) это все равно что f(y) - не понятно, какую функцию выбрать

Ссылки позволяют нам гораздо легче реализовать функцию `swap`
```cpp
void swap(int& x, int& y) {
	int t = x;
	x = y;
	y = t;
}
```

```cpp
int& r;
```
Если не проинициализировать ссылку, то это CE. Ссылки нельзя оставлять без инициализации. Ссылку обязательно при объявлении надо чем-то проинициализировать, иначе CE

```cpp
int& r = 5;
```
Ссылку нужно обязательно инициализировать lvalue, а не rvalue. Поэтому не можем сделать `int& r = x++;`, потому что `x++` возвращает нам rvalue. `int& r = ++x;` - можно

`++x` как раз и возвращает ссылку на x. Он возвращает нам новое название того же самого. Аналогично и присваивание, и разыменование указателя

Например, на строках. Если операция возвращает `string`, то это значит, что она создает новый `string`, а если операция возвращает `string&`, то она нам дает новое название того, что было раньше

Еще есть const и rvalue ссылки

Можем возвращать ссылку из функции
```cpp
int& g(int& x) {
	return ++x;
}
```
Теперь я могу написать 
```cpp
g(x) = 6;
```
потому что `g(x)` это теперь lvalue - оно возвращает ссылку, ее результат это какая-то переменная, которой можно присваивать

Более естественная запись 
```cpp
v[x] = 6;
```
За счет чего мы можем присваивать что-либо результату квадратных скобочек? За счет того, что их возвращаемый объект - это ссылка. Они не создают нам новый объект, они дают нам другой способ именовать то, что уже где-то под ними лежит.

По сути когда мы пользуемся квадратными скобочками в векторе, мы делаем разыменование некоторого указателя - в векторе хранится массив и мы делаем разыменование какой-то ячейки этого массива, получаем саму ячейку и возвращаем ее по ссылке. Тем самым результату квадратных скобочек мы можем присваивать, и это присваивание будет означать модификацию той самой ячейки

Можем сделать и 
```cpp
int& t = g(x);
int t = g(x); // скопируй
```

### Lvalue to Rvalue conversion

### Dangling reference (висячая ссылка)
```cpp
int& f(int& x) {
	int y = ++x;
	return y;
}

int x = 0;
int& y = f(x);
```
Это UB, один из классических и часто встречающихся примеров

Создал переменную, время жизни которой заканчивается, когда заканчивает работать функция, а ссылку на переменную вернул наружу. Получается, когда я вышел из этой функции у меня есть другое имя для переменной, а самой переменной уже нет, а имя все еще валидно

Если приняли что-то в функцию по значению, а потом вернули из этой функции по ссылке, то это тоже dangling reference, потому что это та переменная локальная для этой функции

```cpp
int& f() {
	static int y = 0;
	return y;
}
```
Это корректная запись, потому что `y` существует все время работы программы, она не уничтожается, когда мы выходим из `f`, а значит возвращать ссылку на нее и обращаться к ней по этой ссылке тоже корректно. Аналогично если бы `y` была глобальная переменная/поле класса

```cpp
int& g() {
	int* p = new int(1);
	return *p;
}

int& x = g();
delete &x;
```
Это тоже корректная запись, никаких ошибок не будет

Если написать `int x = g();`, то это уже будет ошибка, попробую удалить копию `x`, он будет на стеке, поэтому получу скорее всего segmentation fault

### Ссылка на указатель
```cpp
int x = 0;
int* p = &x;
int*& p2 = p;
```
Корректная запись, p2 теперь тот же самый указатель, что и p. Буквально

Если потом сделать
```cpp
p = new int(5);
delete p2;
```
то все будет корректно работать

***`int&*` делать нельзя, это сразу CE***
Указателя на ссылку не бывает, как и ссылок на ссылку

### Ссылка на массив
```cpp
int a[10];
int (&b)[10] = a;
```
`b` это ссылка на массив `a`. Теперь `b` это то же самый массив, что и `a`

Читается аналогично, смотри cdecl

Можно передать массив в функцию по ссылке

***Массив из ссылок создать нельзя***
`int& c[10]` нельзя

### Ссылка на функцию
Можно создать ссылку на функцию

```cpp
void f(int);

void (&g)(int) = f;
```
Создали ссылку на функцию `f`

Не знаем, где это может пригодиться