```cpp
int a[10];
```
Объявили массив из 10 интов. Можем написать `type name[amount];`

Можно проинициализировать его элементы сразу
```cpp
int a[5] = {1, 2, 3, 4, 5};
```
Аналогично, можно сразу проинициализировать и `std::vector`

В таком случае можно даже не писать размер массива, он вычислится автоматически, в зависимости от количества переданных аргументов
```cpp
int a[] = {1, 2, 3};
```

Можно указать размер, но не перечислить все аргументы, а только часть, или вообще оставить фигурные скобочки. Тогда оставшиеся заполнятся нулями
```cpp
int a[5] = {1, 2};
int b[5] = {};
```

Если просто написать `int a[5]`, то все 5 элементов заполнятся рандомными числами

Можно не писать равно, а написать `int a[5]{1, 2};`

Можно обращаться по индексу `a[1] = 1;`. Индексация начинается с нуля

Если выйти за границы массива, то это UB. Если выйти за границы массива слишком далеко, то это будет segfault, потому что массив хранится на стеке, и значит мы пытаемся далеко за границы доступного мне стека что-то записать

Можно использовать отрицательные индексы, они иногда бывают полезны

Если завести слишком большой массив (например, 10000000), то будет segfault. Потому что происходит stack overflow - завели на стеке слишком большой массив

Если написать 
```cpp
static int a[10'000'000];
```
То все будет нормально, потому что мы попросим хранить этот массив в статической памяти, а не на стеке - выделить под нее ту самую `data`. Будет выделена заранее, при старте программы

Массивы можно использовать как указатель на его тип. Массив можно разыменовать - получим начальный элемент массива. Можем к массиву добавлять числа, как если бы это был указатель и тем самым получать указатель на другие его элементы
```cpp
int a[5] = {1, 2, 3, 4, 5};
std::cout << *a; // 1
std::cout << *(a + 3); // 4
```
То есть массив неявно преобразуется в указатель на свой первый элемент. Это называется ***`Array To Pointer Conversion` - когда могу использовать массив в роли указателя***

#### Когда полезен отрицательный индекс?
`[ ]` не совсем полноценный оператор, а больше такой синтаксический сахар, штука для удобства письма

Когда мы пишем `a[2]` на самом деле, это эквивалентно `*(a + 2)`. Это буквально одно и то же, настолько, что если у меня есть указатель, то я тоже могу к нему обращаться квадратными скобочками

Массивы и указатели можно использовать взаимозаменяемо

Могу сделать так
```cpp
int a[5] = {1, 2, 3, 4, 5};

int* p = a + 3;
std::cout << p[-1]; // 3
```

Можем указатель поставить на какой-нибудь элемент массива в середине и дальше продолжать обращаться через этот указатель как будто это массив, но индексация будет идти и в отрицательную сторону

Можно написать даже `2[a]`, это то же самое, что и `a[2]` и `*(a + 2)`

Получается у нас есть три разных способа указать на один и тот же элемент

Когда я делаю `[ ]`, я делаю `*` (разыменование) от сдвинутого указателя. ***Но так работает только для массивов!*** Если есть вектор или строка, то для них это работает уже иначе. Только для сишных массивов

Но несмотря на то, что массивы и указатели похожие вещи,. нельзя считать, что это одно и то же. Массивы от указателей все таки отличаются. Они отличаются тем, какие операции над ними разрешены:
- массивам нельзя ничего присваивать
- нельзя инкрементировать массив
- нельзя делать составные присваивания
Это все CE

Еще одно различие - `sizeof` будет давать разный результат. Массив вернет его суммарный размер, а указатель скорее всего 8

Еще может возникнуть путаница между указателями и массивами, когда мы передаем их в функцию
```cpp
void f(int* a) {
	std::cout << "Hi!" << a[2];
}
```
В такую функцию я могу отдать массив, который неявно преобразуется в указатель

Но функция не знает что она принимает массив, она принимает именно указатель

Если у нас есть функция, которая принимает указатель на `int`, то нельзя определить еще и функцию, которая принимает массив из скольких-то там интов. Это будет считаться одной и той же функцией. ***В случае передачи в функцию, указатели и массивы снова не отличимы друг от друга***

Массив в любом случае будет передан как указатель. Когда мы объявляем функцию от массива, в реальности мы объявляем функцию от указателя. Неважно какой размер у массива - при передаче в функцию это все забывается и превращается в указатель

***При передаче в функцию массив буквально превращается в указатель*** - `sizeof` вернет нам 8

### Массивы в динамической памяти
Можно выделить массив в динамической памяти

```cpp
int* a = new int[100];
```
*Не путать `( )` и `[ ]`*

В этой записи все равно есть тонкость - результат того, что получается это все равно указатель, а не массив. Тип переменной `a` это настоящий, чистейшей воды указатель, ее размер будет 8

С этим массивом мы можем спокойно работать. Когда закончим с ним работать, надо его освободить. Для этого пишем 
```cpp
delete[] a;
```

Важно, что здесь надо написать именно `delete[]` - в противном случае будет UB

### В чем разница между delete и delete[] ?
Разница в том, что под капотом, функция, которая занимается выделением и освобождением памяти (находится в сишной библиотеке и обращается к ОС). 

Разница между `delete` и `delete[]` в том, что для массива, как правило надо запомнить, сколько в нем было элементов, чтобы его корректно освободить. Это делает за нас оператор `new`с квадратными скобочками

Когда пишем `new int[100]`, то на практике, скорее всего где-то перед самим массивом, запоминается, сколько в нем лежало элементов

Когда пишем `delete[]` он смотрит на то, что написано перед началом массива (сколько мы выделили) и в зависимости от этого что-то решает делать. А когда пишем `delete` просто, он решает что там один элемент, который просто надо освободить

***Это все не документировано стандартом C++ как это все происходит. Это все другого уровня абстракции***

На практике, скорее всего, перед массивом хранится число, обозначающее его размер и возможно еще какой-то сдвиг. И `delete[]` опирается на это, когда пытается освободить этот массив

Можно увидеть это число (оно скорее всего занимает 8 байт), но это гарантированная UB, в проде не повторять
```cpp
int* a = new int[100];

std::cout << *(a - 2);
```
Оно примерно соответствует тому, сколько байт я выделил под массив

### Массивы переменной длины
Это такие массивы, у которых размер не известен на этапе компиляции, а определяется в run-time. Динамические массивы к ним не относятся, потому что на самом деле динамические массивы - это указатели

```cpp
int n;
std::cin >> n;

int a[n];
```
Так делать нежелательно, потому что  стандарт C++ запрещает так делать. Оно будет компилироваться и даже работать. Компилятор их разрешает для обратной совместимости с C (в C они были разрешены, в C++ запрещены)

*`VLA` - Variable Length Arrays*

Запрещены потому что использование таких массивов накладывает дополнительные расходы в `run-time` - когда у нас массив размера на стеке не известен в `compile-time`, это приводит к тому, что если мы после него будем класть что-то на стек, у нас компилятор не может превратить в правильные шаги по стеку, потому что он не знает, какие будут смещения у всех переменных, которые будут на стеке после этого массива лежать, относительно начала стека. Он их узнает только в `run-time`, а это значит, что чтобы обратиться к каждой из переменных, которые лежат правее, ему придется в `run-time` вычислять смещение относительно начала стека до этой переменной. Это дополнительное замедление. А если таких массивов несколько, то это еще хуже

*Если пишем на плюсах, то лучше не используем сишные массивы*

### Двумерные массивы
```cpp
int a[5][5];
```
Объявил массив из 5 массивов из 5 элементов

```cpp
int* b[5];
```
Массив из 5 указателей на `int`

*Чтобы правильно это читать, вспоминаем правило для операторов - то, что справа сильнее прицеплено к имени, чем то, что слева - читаем сначала вправо, потом влево*

Как объявить указатель на массив?

Для этого используем скобочки при определении типа
```cpp
int (*c)[5];
```
Указатель на массив из 5 `int`

### C-style strings
Чтобы распознать конец строки было соглашение, что строка заканчивается тогда, когда в ней встречается символ с кодом 0

```cpp
char s[] = "abcdefghi";
```
Когда мы пишем такую строку, то неявно к ней добавляется символ с кодом 0. И на самом деле такая строка занимает не 9 байт, а 10. Хранится она в статической памяти (сам литерал, сам текст), а переменная `s` лежит на стеке

Когда мы работаем с сишными строками, на самом деле мы работаем с указателями на некоторые данные в статической памяти, сама строка в статической памяти лежит

Символ с кодом ноль - терминальный символ строки

Вывод строки на экран работает до терминального символа

```cpp
const char* s = "abcd\0";
std::cout << s;
```
Я попросил вывести в поток указатель на `char`, но для указателя на `char` вывод в поток определен особым образом, не так, как для дргуих указателей, потому что указатели на `char` это обычно строки и указатели на `char` в поток выводятся таким образом - разыменовывают этот указатель и идут до тех пор, пока не встретят символ с кодом 0

Все функции для работы со строками действуют до первого символа с кодом 0 (strcp, strlen и т.п.)

Сишные строки довольно опасны, потому что можно случайно прочитать память, которую нам не позволено читать

### Указатели на функции
В C++, так же как и в С, можно объявлять указатели на функции

У нас есть область памяти, в которой лежит исполняемый код

Реализация функции в машинных кодах где-то записана в этой области памяти. Когда мы берем указатель на функцию, это надо понимать как то, что мы взяли указатель на начало этой области памяти, в которой машинные коды, в которой реализация памяти записана

Это может быть надо, если необходимо реализацию функции передать в функцию (например, в `std::sort` свой компаратор)

```cpp
bool cmp(int x, int y) {
	return x > y;
}

int main() {
	int a[5] = {5, 8, 3, 2, 6};

	std::sort(a, a + 5, &cmp);
}
```

Как объявить указатель на функцию?
```cpp
bool (*p)(int, int) = &cmp;

// return-type (*name)(args)
```
Указатель на функцию, которая принимает два `int` и возвращает `bool`

Можно даже не использовать амперсанд, а просто назвать имя функции и оно неявно сконвертируется - `Function To Pointer Convertion`

Если просто попросить вывести значение этого указателя 
```cpp
std::cout << p;
```
то получим 0 или 1, в зависимости от того, `nullptr` или нет.

Можем явно попросить вывести адрес
```cpp
std::cout << (void*)p;
```

Если функция перегруженная, то просто взять ее адрес в каком-то из expressions - это ошибка, потому что не понятно, какая из перегрузок берется

Но если мы делаем объявление указателя на функцию, в зависимости от того, какой тип слева, выражение справа даст правильный результат
```cpp
void f(int) {}
void f(double) {}

int main() {
	void (*p)(int) = &f;
	void (*p2)(double) = &f;
}
```
Получили два разных указателя - две разных функции, находящиеся по разным адресам

Перегрузка происходит не только когда я вызываю функцию, но еще когда я беру на нее адрес

***Нельзя взять адрес у функции, которая не определена***. Если функция не определена, значит у нее нет тела, а значит в машинном коде нет места, где код этой функции записан. Поэтому если попробуем взять адрес на функцию, которая не определена, то получим ошибку линковщика, как если бы я попытался вызвать неопределенную функцию

### Default Arguments
У функций могут быть аргументы по умолчанию. Можем, объявляя какую-то функцию, сказать, что у функции есть аргументы по умолчанию. Это значит, что в функцию я их могу и не передавать, тогда подставятся значения по умолчанию. А могу их передать и тогда они заменят умолчательные значения. Могу передать один из них и тогда первый заменится, а остальные по умолчанию

Аргументами по умолчанию могут быть только последние. Нельзя сделать первый аргумент значением по умолчанию, а второй без значения по умолчанию

### Variadic functions
Не будем ими пользоваться никогда, просто надо знать, что они есть

Это пришло к нам из языка C. Были функции, которым можно передавать переменное число аргументов - в параметрах написано `...`, значит функция принимает любое число аргументов, любых типов; может принимать что-то, а потом `...`, это значит, что она принимает обязательно вот это, а потом еще что-то

Такими функциями являются `printf` и `scanf`

Кодстайл не рекомендует ими пользоваться
