Память бывает статическая, динамическая и автоматическая. Это разные области памяти

*`RAM` - Random Access Memory*

Когда наша программа только запускается, она загружается в оперативную память и под нее выделяется какой-то непрерывный кусочек оперативной памяти, в рамках которого мы можем обращаться по адресам. Если попробуем обратиться куда-то за пределы этого кусочка, разыменовать там что-то, то скорее всего получи `Segfault`

В рамках этого кусочка память тоже делится на области:
- `data` - статическая память (`static memory`). В ней хранятся глобальные переменные, некоторая другая информация, которая существует в течение всего времени жизни нашей программы (локальные статические переменные; строки и литералы, которые мы объявили в программе; таблицы виртуальных функций и т.п.)

Размер области `data` определяется тем, сколько у нас глобальных переменных и прочей статической информации, которую надо хранить. Фиксирован заранее, при запуске. Размер ее записан прямо в бинарнике, сколько байт надо под нее выделить и какая она

- `text` - непосредственно код нашей программы (машинный код, который понятен процессору)

Размер области `text` определяется тем, какой у нас размер бинарного кода в программе

- `stack` - еще называется автоматической памятью (`automatic memory`). Статическая память и стек - это разные виды памяти. В ней хранятся локальные переменные. Называется `stack`, потому что как `stack` она и работает

Когда вводится новая локальная переменная у нас в рантайме процессором поддерживается `stack-pointer`, изначально указывающий на начало стека. Когда процессор исполняет код и видит новую переменную, делается `push` на этот `stack` и `stack-pointer` смещается. `Stack-pointer` это не какая-то переменная, это то что процессор хранит в себе прямо по ходу выполнения (некоторый адрес, где в данный момент вершина стека). Когда переменная снимается со стека, он указатель двигает обратно. Таки образом происходит `push` и `pop` на стек

***Компилятор не обещает нам, что он будет класть переменные на стек именно в том порядке, в каком мы их объявили. Он может их чуть-чуть переупорядочить в рамках одной области видимости***

*Не гарантируется, что переменные будут лежать на стеке именно в порядке объявления и без пропусков между ними*

Когда программа завершается, все переменные снимаются со стека (то есть просто указатель сдвигается на начало и считается, что там ничего больше не лежит). Если бы переменные были объектами (переменные каких-то классовых типов), то для них вызвались бы еще деструкторы

![](../images/Pasted%20image%2020240905170125.png)

### Что происходит, когда мы вызываем функции?
Когда мы вызываем функции, мы тоже на самом деле занимаем стек

```cpp
void f(int y) {
	std::cout << y + 1;
}
```
Вызов `f` означает, что на стек нам надо положить `y`, потому что это новая локальная переменная для новой области видимости. ***Но это не все.*** Когда мы вызываем функцию, нам на стек мало положить лишь новые локальные переменные, надо еще положить очень важную вещь - ***адрес возврата***

Когда процессор видит вызов функции, он понимает на какой адрес ему прыгнуть, чтобы исполнять код этой  функции, потому что когда компилятор компилировал наш код, то он превратил вызов этой функции в прыжок на конкретный адрес, и вызывая функцию, процессор знает адрес, по которому находится реализация этой функции (это все находится где-то в области `text`). Но когда мы выходим назад из функции, то нигде не записано, куда выходить, ведь функцию могли вызывать из разных мест. Процессору нужна знать адрес в коде (где-то в области `text` знать адрес), какую инструкцию исполнять следующей, после того, как мы вышли из этой функции. То есть грубо говоря, адрес следующей инструкции, которая была после вызова `f`. Ее надо запомнить, прежде чем мы будем заходить в `f`, потому что, когда мы будем выходить из `f` нам надо будет знать, куда выходить. Поэтому на самом деле на стеке хранится еще некоторый `ptr`, который говорит процессору, куда прыгать после того, как `f` завершилась. ***На самом деле все в разы сложнее, но этого достаточно для начального представления***

Размер стека по умолчанию фиксирован и равен примерно 8Мб. Это может варьироваться от системы к системе, от версии к версии. Но как правило несколько Мбайт

***Размер стека - это константа уровня ОС***

У абсолютно всех программ есть стек, потому что у любой программы есть какие-то локальные переменные и функции и их надо где-то хранить

### Что будет если стек переполнится?
Считается, что нам достаточно 8Мбайт, чтобы хранить локальные переменные и вызовы функций

Если стек переполнится, то будет ошибка `stack overflow` и наступит `segmentation fault`, потому что в какой-то момент мы выходим за границу памяти, к которой нам разрешено обращаться и через некоторое время ОС нас убивает

Размер всей памяти которую получает программа известен сразу, при запуске. ОС видит размер `text`, размер `data` и добавляет 8Мбайт стека

```cpp
void f(int x) {
	std::cout << ++x << '\n';
	f(x);
}

int main() {
	f(0);
}
```
Классический пример `stack overflow`

Один вызов функции может занимать примерно 24 байта

*Когда мы обращаемся к памяти, мы обращаемся к ней напрямую*

`segfault` происходит не сразу. Когда мы превзошли стек, нас убьют не сразу. Сначала начинается UB - обращаемся за пределы стека, каждое наше следующее обращение это риск того, что нас убьют, но может и повезти. Если зайдем достаточно далеко, то нас точно убьют. Поэтому нельзя точно сказать, когда именно случится `segfault`

***`segmentation fault` - это ошибка, происходящая, когда наша программа, по отношению к операционной системе (памяти) совершила недопустимую операцию, за что ОС убивает нашу программу с таким вердиктом***

### Динамическая память
Используется для выделения переменных и объектов больших размеров

Динамическая, потому что выдается нам в рантайме. Статическая память - та память, которая уже на момент компиляции известна, чему будет равна

Динамическая может быть в рантайме, по ходу программы запрошена и освобождена

### operator new
Используется, чтобы выделить динамическую память

```cpp
int* p = new int;
```
Выделили в динамической памяти одну переменную типа `int`

`new` - оператор, встроенное в язык ключевое слово с предопределенным смыслом, вместе `new int` - это expression, но у него особое действие. Наша программа в этот момент возьмет и попросит у ОС дополнительно `sizeof(T)` байт вдобавок к тому, что у нее уже есть, попросит их из динамической памяти. Когда ОС их выдаст, нам вернется указатель на первый байт из тех, что нам выдали

Чтобы освободить память, которую мы выделили, надо написать `delete p`, где `p` это тот самый указатель, который нам вернули в ответ на `new`

Если после `delete p` попробуем обратиться к памяти по адресу `p`, то на скорее всего убьют

После `delete p`, то, что лежит под `p` больше не наше, хотя сама переменная `p` наша - она лежит на стеке, а `int` под `p` лежит в динамической памяти

Можем выделить сразу массив
```cpp
int* pa = new int[10000]; 
// создай 10000 int, лежащих подряд и верни мне указатель на первый из них
```
Нам вернется указатель на первый `int` в этом массиве. Можем брать его и быть уверенными, что справа от него лежит еще 9999 `int'ов`, можем ходить влево вправо от него и т.п. Нам дали этот кусок в динамической памяти

Чтобы удалить массив используем `delete[] pa;`

Если хотим сразу чем-то проинициализировать, то надо написать 
```cpp
int* p = new int(5);
```
Создай один `int` со значением `5` и верни мне указатель на него

***В отличие от всех прочих языков, в C++ нам необходимо делать `delete` вручную. Это одна из главных причин, почему C++ такой быстрый и почему на нем сложно писать***

Есть проблема: *я могу создать какую-то штуку в динамической памяти и у меня будет указатель на нее. И этот указатель мы можем потерять до того, как мы сделаем `delete`.* В этому случае произойдет `memory leak` (утечка памяти)

***`Memory Leak` - ситуация, когда мы выделили что-то в динамической памяти и потеряли указатель на то, что мы выделили, и теперь мы никак не можем сказать освободить это. ОС продолжает думать, что мы эту память занимаем и не отдает ее никому***

Утечка памяти, это очень частая ошибка на плюсах. Дебажить их довольно неприятное занятие

**Оператор `delete` плохой и неудобный.** Если хоть немножко ошибемся в том, что очищаем, то это сразу UB или segfault. Например, сдвинем чуть чуть указатель, по которому выделили, а потом очищаем его

Если сделаем `delete` того же самого второй раз, то это RE, вылетим с вердиктом `aborted`

Если сделаем `delete` указателя на стеке, а не в динамической памяти, то это будет segfault

Но формально все это UB.

Можно делать `delete` только от того, что нам дали, ни на шаг не сдвинутым, и только один раз. Иначе все сразу плохо

```cpp
int* p = new int;
int* pp = new int;

delete p, pp;
```
Здесь `delete p, pp;` - это expression с оператором запятая. `delete` это тоже запятая, у него приоритет выше запятой (у нее самый низкий приоритет). То есть мы просто удалили `p`, а с `pp` ничего не сделали

### Статические переменные
В `data` хранятся глобальные переменные. Можно попросить, чтобы какая-то конкретная переменная была статической, то есть лежала не на стеке, а в `data`, то есть существовала в течении всего времени работы программы - можем попросить какую-то переменную быть `static`

```cpp
static int x = 0;
```
Просим чтобы эта переменная лежала в области памяти не стековой, а статической, то есть, чтобы за ней был закреплен один и тот же адрес на все время жизни программы, чтобы она отдельно лежала от всего стека

```cpp
void f() {
	static int x = 0;
	std::cout << ++x << std::endl;
	f();
}
```
Когда в первый раз зайду в эту функции переменная проинициализируется нулем, а дальше, когда буду заново заходить в эту функцию, уже ничего не будет с этой переменной происходить. Она уже создана и проинициализирована, память под нее была уже предвыделена заранее, нулем она проинициализируется в момент, когда я впервые зайду в эту строчку кода

Это *локальная статическая переменная (`local static variable`)*

Память под `static` зарезервирована заранее. Компилятор, когда компилирует код, он видит, сколько в нем всего статиков и заранее тем самым знает, каким должен быть размер `data`. Поэтому заранее, статически, на момент компиляции, будет известно, где будет храниться эта переменная и сколько она будет там лежать. Отсюда и название `static` - потому что в `compile-time`

*Статическое, то что в `compile-time` известно, динамическое, то что в `run-time` происходит*

Можно создать статический массив большого размера (например, на гигабайт). А если попробовать создать его на стеке, то сразу получим `segmentation fault`
