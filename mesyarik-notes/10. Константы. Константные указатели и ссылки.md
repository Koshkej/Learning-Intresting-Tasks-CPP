`const` будет приносить нам много боли, будем решать проблемы, которые оно нам приносит, или радоваться тому что оно у нас есть

В C не было констант, поэтому работает 
```cpp
char* s = "abc";
```
для обратной совместимости с С

```cpp
const int c = 2;

int x = 5;
const int y = x;
```

`const` модификатор типа, который делает тип константным - над этим типом запрещены модифицирующие операции

### Как правильно представлять себе константы, какая должна быть интуиция?
Это просто другой тип, у которого часть операций исходного типа отсутствует. Тип над которым часть операций запрещена в Compile-Time (нет присваивания, инкремента, декремента, составного присваивания)

По сути как целые и натуральные числа

*Иногда константы можно изменять, а изменять то, что не является константой - нельзя изменять*

Константу можно проинициализировать переменной или какой-то константой (числом, чаром и т.п.)

```cpp
int x = 5;
const int y = x;
int z = y;
```

`y` поддерживает часть операций над `int`, а `z` и `x` - все

Можно писать слева и справа от типа 
```cpp
const int x = 5;
int const y = 5;
```

### const в комбинации с указателями и ссылками
Самое веселое, когда комбинируем `const` с указателями и ссылками

```cpp
int x = 5;
int* p = &x;

const int* pc = p; // указатель на const int
int* const cp = p; // const указатель на int
```

- Могу поменять `pc`, но то что под ним лежит изменить нельзя. Разыменование `const int*` дает мне `const int`

- Не могу поменять сам `cp`, но то, что под ним поменять можно - разыменование `int* const` дает мне `int`

Если переставим `const int*` на другую переменную, которая не является сама по себе `const`, то изменить то, что лежит по этому указателю все равно не получится - не важно какой тип у переменной по этому указателю, важно, что тип этого указателя - `const int*`, то есть `*` от него - это `const int`, а ему нельзя присваивать

```cpp
const int* const cpc = p; // const указатель на const int
```
И сам указатель и то, что под ним нельзя менять

**Это именно CE, проверяется на этапе компиляции. Константность - запрет некоторых операций, поэтому корректность проверяется полностью в compile-time**

```cpp
int x = 5;
int* p = &x;

const int* pc = p // int* -> const int*
```

Произошло преобразование. Это не просто навесить `const` на тип. Подложил `const` под указатель. Это *неявное преобразование константности*, неявный `const_cast`, когда мы подкладываем `const` под `*`

В обратную сторону делать нельзя

```
int* -> const int* можно всегда

const int* -> int* нельзя
```

```cpp
int x = 5;
const int* p = &x;

++x;
std::cout << *p; // 6
```

Тот факт, что у меня есть указатель на `const int` еще не означает, что `int` который лежит под ним никогда не поменяется. Это дает мне гарантию, что через этот указатель я не смогу его поменять, но не дает гарантий что кто-то другой не может его поменять используя другую переменную

Результату такого разыменования ничего нельзя присвоить, но не отменяет факта, что результат разыменования является lvalue

Может быть, что на одну переменную будет и обычный указатель и указатель на константу. По сути как права на запись и на чтение

### Ссылки
```cpp
int x = 5;
const int& r = x;
```

`r` новое название для `x`, но с ограниченными правами. То же самое что и `x`, но называя его `r` лишаемся части прав по отношению к нему

Если кто-то поменяет `x`, то `r` так же изменится

*Тот факт, что у меня `const int& r` еще не означает, что `r` нельзя поменять. Это означает, что ИСПОЛЬЗУЯ `r` ЕГО НЕЛЬЗЯ ПОМЕНЯТЬ*

Запрещены модифицирующие операции над `r`

```cpp
int& const r = x; // лишено смысла
```

Для ссылок н имеет смысла писать `const` справа - она никогда не может быть переставлена на что-то другое

```cpp
int x = 5;
const int& r = x;
int& r2 = r; // CE
```
`r` дает право только на чтение и строкой с `r2` нарушаю права - пытаюсь добавить права, которых у меня не было. В обратную сторону все ок (взять доступ только на чтение к переменной, к которой был доступ и на запись и на чтение)

```cpp
const int x = 5;
int& y = x; // CE
```

Константа должна быть проинициализирована сразу же, в момент объявления

```cpp
const int* p = new const int; // CE
const int* p = new const int(2); // OK

const int* pa = new const int[10]; // CE, не проинициализирвоал 10 констант
```

### Functions
Всегда думаем, как мы хотим принимать не тривиальный аргумент в функцию (для которого копирование может быть долгим) - по ссылке, по значению, по константной ссылке

Указатели принимать не рекомендуется - C-style

1) Если просто принимаем значение, то не надо делать его константным - бессмысленно (запрещаем себе менять локальную копию)
2) Если хочу из  функции менять объект, который я передал, и чтобы это влияло на исходный объект, то передаю его по ссылке
3) Если не собираюсь менять то, что принял, и просто хочу с ним работать - принимаем по константной ссылке (не делаем дорогое копирование)

```cpp
void f(const std::string&);

f("abcde");
```

Пытаюсь вызвать `f` от объекта, которому не соответствует никакая переменная. Происходит неявная конверсия `const char* -> const std::string&`

*Обычные ссылки инициализировать через rvalue нельзя, а константные можно* - для того, чтобы в функции всегда можно было передавать аргументы по константной ссылке

```cpp
const int& x = 5; // OK
```

Константная ссылка может быть проинициализирована rvalue

```cpp
{
	const std::string& s = "abc";
	/*
	создался объект типа std::string, "abc"
	скопировалось в динамическую память
	*/
	
	// ...
}
```

В какой момент уничтожится переменная `s`? Когда эта ссылка выйдет из области видимости. Компилятор считает это имя реальным именем объекта и все прочие ссылки не будут влиять на уничтожение объекта. Как только закончится время жизни `s` - уничтожится строка

***Это Lifetime expansion***

`s` ведет себя как обычная `const std::string`, она не отличима от обычной строки. Где-то на стеке создалась строка и под нее сразу создалась вот эта ссылка

```cpp
{
	const std::string& s = "aaaa";
}
```

- `"aaaa"` литерал лежит в области data
- на стеке создается строка, которая хранит в себе указатель на динамическую память

Получается 24 байта на стеке (size, capacity, pointer), указатель указывает в кучу, куда скопировался `"aaaa"`

Обращение к строке валидно, пока жив объект `s`

*Переменные примитивных типов нет смысла принимать по константной ссылке - проигрываем в эффективности, так как разыменовывание указателя более долгая операция, чем просто обращение к переменной.* Надо читать память под указателем, а она может быть не загружена в кэш/регистр

### Почему неконстантные ссылки не продлевают жизнь объектам?
Так решил создатель

Если мы введем такое правило, то есть пример, когда все будет плохо
```cpp
void g(size_t& y) {
	++y;
}

int main() {
	int x = 0;
	g(x);
	std::cout << x;
}
```

Если бы продление жизни неконстантными ссылками было бы разрешено, то вывелось бы 0, потому что ссылка позволяет связаться с тем типом, который в точности совпадает с ее типом. В g(x) создался бы временный size_t, который увеличился бы, а потом забылся. Получается в таком случае мог бы случайно ошибившись в типе думать, что из функции поменял объект, а я на самом деле поменял его копию

Такой вызов на самом деле будет CE

```cpp
int x = 10;
const double& d = x;
```
Так можно. `x` неявно сконвертируется в double, и именно к этому временному double и привяжется ссылка. То же самое происходило, когда инициализировал const std::string& C-style строкой

```cpp
void f(const std::string&); // здесь нужна неявная конверсия - подложить const под ссылку

void f(std::string&); // exact type matching, точное совпадение типа

int main() {
	std::string s = "abc";

	f(s);
}
```

Это корректная операция, можно определять разную обработку для константных и неконстантных объектов. **НО ТОЛЬКО ДЛЯ ССЫЛОК, для обычных типов непонятно, какую версию вызвать**

```cpp
const int& g(int x) {
	return x++;
}
```

UB - создал временное значение rvalue и вернул константную ссылку на него, произошла висячая ссылка

Lifetime expansion работает только тогда, когда мы объявляем локальную переменную с его помощью

```cpp
int* p = new int(0);

int** pp = &p;

const int** cpp = pp; // CE
```
Нельзя неявно добавлять const глубже, чем на один уровень под указатель.

Почему так нельзя делать?

```cpp
int main() {
	const char x = 'a';
	char* p = nullptr;
	const char** q = &p;
	*q = &x;
	*p = 'b';
	std::cout << x;
}
```

Если сразу навесить const под два уровня, то все будет окей
```cpp
const char* const* q = &p; // OK
```
